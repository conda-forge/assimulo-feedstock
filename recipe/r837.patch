Index: src/implicit_ode.pyx
===================================================================
--- assimulo/implicit_ode.pyx	(revision 836)
+++ assimulo/implicit_ode.pyx	(revision 837)
@@ -26,7 +26,7 @@
 cimport numpy as N
 
 from exception import *
-from time import clock, time
+from timeit import default_timer as timer
 import warnings
 
 realtype = N.float
@@ -187,7 +187,7 @@
         output_index = 0
         
         self.time_limit_activated = 1 if self.time_limit > 0 else 0
-        self.time_integration_start = time()
+        self.time_integration_start = timer()
 
         while (flag == ID_COMPLETE and tevent == tfinal) is False and (self.t-eps > tfinal) if backward else (self.t+eps < tfinal):
 
@@ -203,7 +203,7 @@
             
             #Initialize the clock, enabling storing elapsed time for each step 
             if REPORT_CONTINUOUSLY and self.options["clock_step"]: 
-                self.clock_start = clock()
+                self.clock_start = timer()
                 
             [flag, tlist, ylist, ydlist] = self.integrate(self.t, self.y, self.yd, tevent, opts)
 
@@ -274,16 +274,16 @@
                 
         #Store the elapsed time for a single step 
         if self.options["clock_step"]:
-            self.elapsed_step_time = clock() - self.clock_start 
-            self.clock_start = clock() 
+            self.elapsed_step_time = timer() - self.clock_start 
+            self.clock_start = timer() 
         
         #Check elapsed timed
         if self.time_limit_activated:
-            if self.time_limit-(time()-self.time_integration_start) < 0.0:
+            if self.time_limit-(timer()-self.time_integration_start) < 0.0:
                 raise TimeLimitExceeded("The time limit was exceeded at integration time %.8E."%self.t)    
         
         if self.display_progress:
-            if (time() - self.time_integration_start) > self.display_counter*10:
+            if (timer() - self.time_integration_start) > self.display_counter*10:
                 self.display_counter += 1
                 
                 sys.stdout.write(" Integrator time: %e" % self.t)
Index: src/ode.pyx
===================================================================
--- assimulo/ode.pyx	(revision 836)
+++ assimulo/ode.pyx	(revision 837)
@@ -17,7 +17,7 @@
 
 import numpy as N
 cimport numpy as N
-import time
+from timeit import default_timer as timer
 import pylab as P
 
 import itertools
@@ -283,13 +283,13 @@
         self.initialize()
         
         #Start of simulation, start the clock
-        time_start = time.clock()
+        time_start = timer()
         
         #Start the simulation
         self._simulate(t0, tfinal, output_list, REPORT_CONTINUOUSLY, INTERPOLATE_OUTPUT, TIME_EVENT)
         
         #End of simulation, stop the clock
-        time_stop = time.clock()
+        time_stop = timer()
         
         #Simulation complete, call finalize
         self.finalize()
Index: src/kinsol.py
===================================================================
--- assimulo/kinsol.py	(revision 836)
+++ assimulo/kinsol.py	(revision 837)
@@ -26,7 +26,7 @@
 import pylab as P
 import operator as O
 import re
-import time
+from timeit import default_timer as timer
 from assimulo.problem_algebraic import *
 
 class KINSOL_Exception(Exception):
@@ -290,9 +290,9 @@
                     self.solver.KINSOL_init(self.func,self.x0,self.dim,jac,self.constraints,self.use_sparse,self.verbosity,self.norm_of_res,self.reg_param,self.fscale)
                 else:
                     self.solver.KINSOL_init(self.func,self.x0,self.dim,jac,self.constraints,self.use_sparse,self.verbosity,self.norm_of_res,self.reg_param,None)
-                start = time.clock()
+                start = timer()
                 res = self.solver.KINSOL_solve(not self._use_ls)
-                stop = time.clock()
+                stop = timer()
                 self.exec_time += (stop - start)
                 solved = True
             except KINError as error:
Index: src/explicit_ode.pyx
===================================================================
--- assimulo/explicit_ode.pyx	(revision 836)
+++ assimulo/explicit_ode.pyx	(revision 837)
@@ -25,7 +25,7 @@
 cimport numpy as N
 
 from exception import *
-from time import clock, time
+from timeit import default_timer as timer
 
 include "constants.pxi" #Includes the constants (textual include)
 
@@ -170,7 +170,7 @@
         output_index = 0
         
         self.time_limit_activated = 1 if self.time_limit > 0 else 0
-        self.time_integration_start = time()
+        self.time_integration_start = timer()
         
         while (flag == ID_COMPLETE and tevent == tfinal) is False and (self.t-eps > tfinal) if backward else (self.t+eps < tfinal):
 
@@ -183,7 +183,7 @@
             
             #Initialize the clock, enabling storing elapsed time for each step
             if REPORT_CONTINUOUSLY and self.options["clock_step"]:
-                self.clock_start = clock()
+                self.clock_start = timer()
             
             flag, tlist, ylist = self.integrate(self.t, self.y, tevent, opts)
             
@@ -248,12 +248,12 @@
         
         #Store the elapsed time for a single step
         if self.options["clock_step"]:
-            self.elapsed_step_time = clock() - self.clock_start
-            self.clock_start = clock()
+            self.elapsed_step_time = timer() - self.clock_start
+            self.clock_start = timer()
         
         #Check elapsed timed
         if self.time_limit_activated:
-            if self.time_limit-(time()-self.time_integration_start) < 0.0:
+            if self.time_limit-(timer()-self.time_integration_start) < 0.0:
                 raise TimeLimitExceeded("The time limit was exceeded at integration time %.8E."%self.t)
                 
         self.chattering_clear_counter += 1
@@ -262,7 +262,7 @@
             self.chattering_ok_print = 1
                 
         if self.display_progress:
-            if (time() - self.time_integration_start) > self.display_counter*10:
+            if (timer() - self.time_integration_start) > self.display_counter*10:
                 self.display_counter += 1
                 
                 sys.stdout.write(" Integrator time: %e" % self.t)
Index: src/algebraic.pyx
===================================================================
--- assimulo/algebraic.pyx	(revision 836)
+++ assimulo/algebraic.pyx	(revision 837)
@@ -17,7 +17,7 @@
 
 import numpy as N
 cimport numpy as N
-import time
+from timeit import default_timer as timer
 import pylab as P
 
 import itertools
@@ -102,13 +102,13 @@
         self.initialize()
         
         #Start of simulation, start the clock
-        time_start = time.clock()
+        time_start = timer()
         
         #Start the simulation
         self.y = self._solve(y)
         
         #End of simulation, stop the clock
-        time_stop = time.clock()
+        time_stop = timer()
         
         #Simulation complete, call finalize
         self.finalize()
